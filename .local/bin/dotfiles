#!/bin/sh
# Uses git for managing dotfiles
set -eu

export GIT_DIR="$HOME/.dotfiles.git"
export GIT_WORK_TREE="$HOME"

usage() {
	script="$(basename "$0")"
	cat <<EOF
Usage:

$script init
	Creates a fresh dotfiles setup in '$GIT_WORK_TREE', using '$GIT_DIR' as a bare git directory.

$script clone [git options] <remote>
	Clones a remote repository to be used locally. This also pulls in any submodules that might exist in the repository.

$script <git options other than init and clone>
	Runs git with specified options on the dotfiles setup. Examples:
	$script pull
	$script checkout main
	$script add some files
	$script status
	$script commit -m 'some message'
	$script push
	... etc.

Examples:

Using a bundle file for cloning the repository to another machine, without using GitHub or other central repository:
	alice\$ $script bundle create dotfiles.bundle main
	alice\$ scp dotfiles.bundle bob:
	bob\$ $script clone --branch main dotfiles.bundle

The commands above create a 'remote' entry in '$GIT_DIR/config' pointing to the bundle. Future updates can be performed by copying a new bundle file and pulling from it:
	alice\$ $script bundle create dotfiles.bundle main
	alice\$ scp dotfiles.bundle bob:
	bob\$ $script pull origin main

Source of idea: https://www.atlassian.com/git/tutorials/dotfiles
EOF
}

init() {
	git init --bare "$GIT_DIR"
	git config --local status.showUntrackedFiles no
}

clone() {
	if [ $# -eq 0 ]; then
		echo "Error: No remote specified for cloning" >&2
		echo "" >&2
		usage
		exit 1
	fi
	git clone --bare "${@}" "$GIT_DIR"
	git config --local status.showUntrackedFiles no
	git submodule update --init --recursive
}

if [ $# -eq 0 ]; then
	usage >&2
	exit 1
fi

case "$1" in
	init) shift; init;;
	clone) shift; clone "${@}";;
	*) git "${@}";;
esac
